-- ASDL's 4 builtin types are:
-- identifier, int, string, constant

module Antomic
{
    mod = Module(stmt* body)
        | Expression(expr body)

    stmt = FunctionDef(identifier name, arguments args, stmt* body)

          | ClassDef(identifier name, baseclasses bases, stmt* body)
          | Return(expr? value)

          | Delete(expr target)
          | Assign(expr target, expr value)
          | AugAssign(expr target, operator op, expr value)

          | For(expr target, expr iter, stmt* body)
          | While(expr test, stmt* body)
          | If(expr test, stmt* body, stmt* orelse)

          | Raise(expr? exc, expr? cause)
          | Try(stmt* body, excepthandler* handlers, stmt* finalbody)
          | Assert(expr test, expr? msg)

          | Import(alias* names)
          | ImportFrom(identifier? module, alias* names)

          | Expr(expr value)
          | Pass | Break | Continue

          -- col_offset is the byte offset in the utf8 string the parser uses
          attributes (int lineno, int col_offset)

          -- BoolOp() can use left & right?
    expr = BoolOp(expr left, boolop op, expr right)
         | BinOp(expr left, operator op, expr right)
         | UnaryOp(unaryop op, expr operand)
         | Lambda(arguments args, expr body)
         | IfExp(expr test, expr body, expr orelse)
         | Dict(expr* keys, expr* values)
         | Set(expr* elts)
         -- need sequences for compare to distinguish between
         -- x < 4 < 3 and (x < 4) < 3
         | Compare(expr left, cmpop* ops, expr* comparators)
         | Call(expr func, expr* args)
         | FormattedValue(expr value, int? conversion, expr? format_spec)
         | JoinedStr(expr* values)
         | Constant(constant value, string? kind)

         -- the following expression can appear in assignment context
         | Attribute(expr value, identifier name, expr_context ctx)
         | Subscript(expr value, expr sliceRead, expr_context ctx)
         | Starred(expr valueRead, expr_context ctx)
         | Name(identifier idRead, expr_context ctx)
         | List(expr* eltsRead, expr_context ctx)
         | Tuple(expr* eltsRead, expr_context ctx)

         -- can appear only in Subscript
         | Slice(expr? lower, expr? upper, expr? step)

          -- col_offset is the byte offset in the utf8 string the parser uses
          attributes (int lineno, int col_offset)

    expr_context = Load | Store | Del

    boolop = And | Or

    operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift
                 | RShift | BitOr | BitXor | BitAnd | FloorDiv

    unaryop = Invert | Not | UAdd | USub

    cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn

    excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)
                    attributes (int lineno, int col_offset)

    arguments = (arg* args)

    arg = (identifier arg, identifier type)
           attributes (int lineno, int col_offset)

    baseclasses = (baseclass* base)

    baseclass = (identifier base)
                 attributes (int lineno, int col_offset)

    -- import name with optional 'as' alias.
    alias = (identifier name, identifier? asname)
             attributes (int lineno, int col_offset)
}